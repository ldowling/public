---
title: "R Notebook"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 2
    theme: readable
    code_folding: hide
    self_contained: false
editor_options:
  chunk_output_type: inline
---
### Looking at data collected about 311 service requests in the city of chicago.

```{r dependencies, message=FALSE, include=FALSE, results=FALSE}
source("utils.R")
source("generic_functions/ez_setup.R")
ez_setup(install=TRUE, extras=c("RSocrata","stringr"))
```

### Using this data to answer the following questions:

1. What category of service request is addressed the fastest? The slowest?
2. Do categories of service requests seem to be related to time of year?
3. Which departments are best/worst at closing requests quickly?
4. What kinds of service requests might be related to police presence?
5. Which areas of budget changes are most/least popular?

#### Start off by reading in the initial data table and doing some cleaning. Note that this initial download/load is fairly long since the data set is large.

```{r setup, message=FALSE, cache=TRUE}
sr <- data.table::fread("https://data.cityofchicago.org/api/views/dm4w-zcp5/rows.csv?accessType=DOWNLOAD")
colnames(sr) <- tolower(colnames(sr))
colnames(sr) <- gsub("community_area", "area_id", colnames(sr))
```

* Change column names and the `city` variable to lowercase.
* Rename the `community_area` variable to match the key variable name used later on.
* Filter the data set to only rows that have an Area ID and a Zip Code (this removes about 1.3% of total rows)

##### Several questions can be answered using only data from a subset of the main table which contains the Service Request Number, Type, Status, and related Dates.

```{r q1_setup, cache=TRUE}
sub <- select(sr, sr_number, sr_type, status, ends_with("_date"))
sub[,4:5] <- lapply(sub[,4:5], mdy_hms)
```

* The data contained some blank values which needed to be converted to NA values. 
* The date columns were also initially stored as text so are converted to Date class objects (technically `POSIXct`) to allow analysis.

## **Question #1**
### What categories of service requests are addressed the fastest and slowest?

```{r q1, cache=TRUE}
#subset to just completed requests
completed <- filter(sub, status=="Completed") %>% select(-status) %>% 
             mutate(dur_sec = as.numeric(difftime(.$closed_date,
                                          .$created_date))
                                          ) %>% 
             group_by(sr_type)
#summarize the df of completed requests
dur_sum <- summarise(completed, 
                     day_diff=difftime(closed_date,created_date,units="days")%>%
                              mean() %>% round(digits=8)) %>% filter(day_diff>0.5)
#find some specific values to print the results message
min_idx <- which(dur_sum$day_diff==min(dur_sum$day_diff))
min_time <- as.numeric(dur_sum$day_diff[min_idx])
min_type <- dur_sum$sr_type[min_idx]
min_dur <- nice_dur(min_time)

max_idx <- which(dur_sum$day_diff==max(dur_sum$day_diff))
max_time <- as.numeric(dur_sum$day_diff[max_idx])
max_type <- dur_sum$sr_type[max_idx]
max_dur <- nice_dur(max_time)
```

The results of the analysis found that the fastest request type fulfilled was the **`r min_type`**, with an average completion time of **`r round(as.numeric(min_dur[[1]]), 2)` `r min_dur[[2]]`**. The slowest request type fulfilled was the **`r max_type`**, with an average completion time of **`r round(as.numeric(max_dur[[1]]), 2)` `r max_dur[[2]]`**.

## **Question #2**
### Do categories of service requests seem to be related to time of year?
```{r q2, results="hide", cache=TRUE}
ty <- mutate(sub, month_created=lubridate::month(sub$created_date,label=TRUE)) %>% 
      group_by(sr_type, month_created) %>% summarize(total_req=n()) %>% 
      spread(month_created, total_req)
ty[is.na(ty)] <- 0
ty_sum <- mutate(ungroup(ty), 
                  max = do.call(pmax, c(ty[,-1], na.rm=TRUE)),
                  min = do.call(pmin, c(ty[,-1], na.rm=TRUE))) %>%
                  mutate(.,cv = apply(ty[,c(2:13)], 1,function(x){
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100}))
#high variance codes with a maximum request count of at least 10
ty_hvc <- filter(ty_sum, cv > 100 & max > 10)

to_plot <- select(ty_hvc, sr_type,Jan:Dec) %>% 
           gather(key="month", value="count", -sr_type)
to_plot$month <- factor(to_plot$month, month.abb)

ty_ggplot <- ggplot(to_plot, aes(x=month, y=count, group=1)) +
        geom_line() +
        facet_wrap(~str_wrap(sr_type,width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(angle = 270, hjust = 1))
```

* Add a column to the sub table created previously that notes the month that each request was created. Then group that able by the new month column.
* Generate a summary of requests per month for each type of request.
* Calculate the minimum and maximum number of requests in one month for each request type and then calculate the coefficient of variation for the request types to find those with the *most* variance over a year.
* Filter down to the top `r nrow(ty_hvc)` most highly variant request types and plot them over the course of a year to compare.

```{r q2_plot, echo=FALSE}
print(ty_ggplot)
```

## **Question #3**
### Do categories of service requests seem to be related to time of day?
```{r q3, results="hide"}
td <- mutate(sub, time_exact=make_datetime(hour=hour(sub$created_date),
                                               min=minute(sub$created_date),
                                               sec=second(sub$created_date)) %>% 
                             format(format="%H:%M:%S"),
                  time_hour=hour(sub$created_date)) %>% 
      group_by(sr_type, time_hour) %>% summarize(total_req=n()) %>% 
      spread(time_hour, total_req)
td[is.na(td)] <- 0
td_sum <- mutate(ungroup(td), 
                 max = do.call(pmax, c(td[,-1], na.rm=TRUE))) %>% 
                 mutate(., cv = apply(td[,c(2:25)], 1,function(x){ 
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100} ))
td_hvc <- filter(td_sum, cv > 100 & max > 20)

to_plot <- select(td_hvc, sr_type, `0`:`23`) %>% 
           gather(key="hour", value="count", -sr_type)
to_plot$hour <- as.numeric(to_plot$hour)

td_ggplot <- ggplot(to_plot, aes(x=hour, y=count, group=1)) +
        geom_line() +
        scale_x_continuous(breaks=unique(to_plot$hour)[unique(to_plot$hour)%%2==0], 
               labels=c("12am", paste0(c(2,4,6,8,10),"am"), "12pm", paste0(c(2,4,6,8,10),"pm"))) +
        facet_wrap(~str_wrap(sr_type, width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(size=7, angle = 270, hjust=-0.25, vjust = 0.5))
```

* Add a column to the original sub table that notes the exact time and hour that each request was created. Then group that able by the new `hour` column.
* Generate a summary of requests per hour for each type of request.
* Calculate the maximum number of requests in one hour for each request type and then calculate the coefficient of variation for the request types to find those with the *most* variance over a day.
* Filter down to the top `r nrow(td_hvc)` most highly variant request types and plot them over the course of a day to compare.

```{r q3_plot, echo=FALSE}
print(td_ggplot)
```

## **Question #4**
### Which departments are best/worst at closing requests quickly?
```{r q4}
dep_sp <- select(sr, owner_department, sr_type, 
                 status, created_date, closed_date) %>% 
          filter(status=="completed") %>% select(-status)
dep_sp[,3:4] <- lapply(dep_sp[,3:4], mdy_hms)
dep_sp <- mutate(dep_sp, dur_sec = as.numeric(difftime(dep_sp$closed_date,
                                                dep_sp$created_date))
                ) %>% group_by(owner_department, sr_type) %>% 
       summarise(day_diff = difftime(closed_date,created_date, units="days") %>% 
              mean() %>% round(digits=8), count=n()) %>% filter(day_diff>0.5)
avg_speed <- summarize(dep_sp, avg_req_n_days=mean(day_diff) %>% round (2))
```

# NEED TO STILL ADD SUMMARY STATEMENT FROM CODE ABOVE LIKE AFTER Q1

## Bonus section on budget.

### Looking at some data from a buget survey for FY 2020.
```{r budget, results=FALSE}
budget <- read.socrata("https://data.cityofchicago.org/api/views/drbg-ny73/rows.csv?accessType=DOWNLOAD", "ykQDb7IDvb4jrHDEx6hk7f8uF")

gbudget <- gather(budget, cat, value, -c(date, zip_code, counter_column)) %>% 
           mutate(cat=gsub("(?<=assignment)_","-",cat, perl = TRUE)) %>% 
           mutate(cat=gsub("(?<=change)_","-",cat, perl = TRUE)) %>% 
           mutate(cat=gsub("(?<=interest)_","-",cat, perl = TRUE)) %>% 
           separate(cat, c("category", "type"), sep="-") %>% 
           select(-counter_column) %>% mutate(id=1:nrow(.))
gbudget$value <- gsub("Increase.*","increase",gbudget$value) %>% 
                 gsub(".*Same","no change",.) %>% gsub("Reduce.*","reduce",.) %>% 
                 gsub("No Opinion","no opinion",.) %>% tolower()
gbudget$value[gbudget$value==""] <- NA
gbudget$value[is.na(gbudget$value)] <- "no answer"
gb <- filter(gbudget, category!="X_1000_assignment")
gb_sum <- summarize(group_by(gb, category, type, value), count=n()) %>% 
        filter(value!="no answer")
gb_sum$category <- gsub("_interest","_int",gb_sum$category) %>% 
                 gsub("_change","_cha", .) %>% tolower()
for (gbcat in gb_sum$category) {
  plot <- filter(gb_sum, category==gbcat)
  if (grepl("_int$",gbcat)) {
    plot$value <- factor(plot$value, levels=c("true","false"))
  }else if (grepl("revenue",gbcat)){
    plot$value <- factor(plot$value, levels=c("increase","no change", "no opinion"))
  }else if (grepl("spending",gbcat)){
    plot$value <- factor(plot$value, levels=c("increase","no change", "reduce"))
  }
  plot <- ggplot(plot, aes(str_wrap(str_to_title(gsub("_"," ",type)),
                                    width=16), count, fill=value)) +
     geom_col(position="dodge") +
     #scale_x_discrete(labels=function(x){sub("\\s", "\n", x)}) +
     labs(title=element_blank()) +
     theme(axis.title.x=element_blank(),
           axis.title.y=element_blank(),
           legend.title=element_blank(),
           axis.text.x = element_text(angle=270, hjust=, vjust=0.5))
    assign(gbcat, plot)
}
```

* The budget survey collected data on public interest in receiving more information about revenue and expenses.

```{r budget_plot_1, echo=FALSE}
print(revenue_int + labs(title="Respondent reported interest in information on a source of revenue"))
print(expense_int + labs(title="Respondent reported interest in information on a type of expenditure"))
```

* The survey also asked questions on which revenue changes or spending changes could be made to balance the city's budget. Note that there is no option offered in the revenue section for "decrease revenue".

```{r budget_plot_2, echo=FALSE}
revenue_cha + labs(title=str_wrap("Which revenues would you consider increasing or keeping the same in order to balance the City’s budget?", width=60))
spending_cha + labs(title=str_wrap("Which areas of spending would you consider reducing, increasing or remaining the same in order to balance the City’s budget?", width=70))
```

* Finally, there was a question about how each respondent would allocate $1,000 of the city's budget.

```{r 1_k_assign, echo=FALSE}
assignment <- filter(gbudget, category=="X_1000_assignment") %>% 
              select(-category, -date, -zip_code, -id) %>% group_by(type) %>% 
              filter(type!="total")
assignment[assignment=="no answer"] <- NA
assignment <- filter(assignment, !is.na(value))
assignment$value <- as.numeric(assignment$value)
ggplot(assignment, aes(reorder(str_wrap(str_to_title(gsub("_"," ",type)), 
                                        width=17), value, median), value)) +
            geom_boxplot() +
            coord_flip() +
            theme_classic() +
            labs(title="Amount of a hypothetical $1000 allocated to each area.") +
            xlab(NULL) +
            ylab(NULL) +
            scale_y_continuous(labels = function(x){
                              sub("^","$",ifelse(str_length(x)==4,sub("(^\\d)","\\1,",x),x))})
```