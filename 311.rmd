---
title: "311 Analysis"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 2
    toc_float: true
    theme: flatly
    code_folding: hide
    self_contained: false
editor_options:
  chunk_output_type: inline
---
[Return home](https://ldowling.github.io/public/index.html)

```{r dependencies, message=FALSE, include=FALSE, results=FALSE}
source("utils.R")
source("generic_functions/ez_setup.R")
ez_setup(install=FALSE, extras=c("RSocrata","stringr","knitr","kableExtra"))
```
### Using data collected about 311 service requests in the city of chicago to answer the following questions:
1. What category of service request is addressed the fastest? The slowest?
2. Do categories of service requests seem to be related to time of year?
3. Do categories of service requests seem to be related to time of day?
4. Which departments are best/worst at closing requests quickly?


The data file used as reference for the following analysis is a subset of the [311 Service Requests](https://data.cityofchicago.org/Service-Requests/311-Service-Requests/v6vf-nfxy/data) data set hosted by the [City of Chicago Data Portal](https://data.cityofchicago.org).

Though I was able to subset and filter the original 311 data set, to a certain degree, on the Data Portal itself, I still needed to modify it a little more. Changes include converting column names to lowercase and creating an additional subset that most of the questions will reference. I will refer to this below as "the sub table." I also convert the date columns to the POSIXct format so R can recognize them as such, since they were initially stored as character strings.
```{r setup, message=FALSE, cache=TRUE}
sr <- data.table::fread("https://data.cityofchicago.org/api/views/dm4w-zcp5/rows.csv?accessType=DOWNLOAD")
colnames(sr) <- tolower(colnames(sr))
colnames(sr) <- gsub("community_area", "area_id", colnames(sr))
sub <- select(sr, sr_number, sr_type, status, ends_with("_date"))
sub[,4:5] <- lapply(sub[,4:5], mdy_hms)
```
## **Question #1**
### What categories of service requests are addressed the fastest and slowest?
```{r q1, echo=FALSE, cache=TRUE}
#subset to just completed requests
completed <- filter(sub, status=="Completed") %>% select(-status) %>% 
             mutate(dur_sec = as.numeric(difftime(.$closed_date,
                                          .$created_date))
                                          ) %>% 
             group_by(sr_type)
#summarize the df of completed requests
dur_sum <- summarise(completed, 
                     day_diff=difftime(closed_date,created_date,units="days")%>%
                              mean() %>% round(digits=8)) %>% filter(day_diff>0.5)
#find some specific values to print the results message
min_idx <- which(dur_sum$day_diff==min(dur_sum$day_diff))
min_time <- as.numeric(dur_sum$day_diff[min_idx])
min_type <- dur_sum$sr_type[min_idx]
min_dur <- nice_dur(min_time)

max_idx <- which(dur_sum$day_diff==max(dur_sum$day_diff))
max_time <- as.numeric(dur_sum$day_diff[max_idx])
max_type <- dur_sum$sr_type[max_idx]
max_dur <- nice_dur(max_time)

dur_sum$day_diff <- as.numeric(round(dur_sum$day_diff, 2))
```

The results of my analysis found that the fastest request type fulfilled was the **`r min_type`**, with an average completion time of **`r round(as.numeric(min_dur[[1]]), 2)` `r min_dur[[2]]`**. The slowest request type fulfilled was the **`r max_type`**, with an average completion time of **`r round(as.numeric(max_dur[[1]]), 2)` `r max_dur[[2]]`**.
```{r q1_table, echo=FALSE}
kable(dur_sum[order(dur_sum$day_diff),],align="lc", 
      col.names=c("Request Type", "Average Life of Request (days)")) %>% 
  kable_styling() %>% scroll_box(height="400px")
```
```{r q1_code, eval=FALSE}
#subset to just completed requests
completed <- filter(sub, status=="Completed") %>% select(-status) %>% 
             mutate(dur_sec = as.numeric(difftime(.$closed_date,
                                          .$created_date))
                                          ) %>% 
             group_by(sr_type)
#summarize the df of completed requests
dur_sum <- summarise(completed, 
                     day_diff=difftime(closed_date,created_date,units="days")%>%
                              mean() %>% round(digits=8)) %>% filter(day_diff>0.5)
#find some specific values to print the results message
min_idx <- which(dur_sum$day_diff==min(dur_sum$day_diff))
min_time <- as.numeric(dur_sum$day_diff[min_idx])
min_type <- dur_sum$sr_type[min_idx]
min_dur <- nice_dur(min_time)

max_idx <- which(dur_sum$day_diff==max(dur_sum$day_diff))
max_time <- as.numeric(dur_sum$day_diff[max_idx])
max_type <- dur_sum$sr_type[max_idx]
max_dur <- nice_dur(max_time)

dur_sum$day_diff <- as.numeric(round(dur_sum$day_diff, 2))

#generate output table
kable(dur_sum[order(dur_sum$day_diff),],align="lc", 
      col.names=c("Request Type", "Average Life of Request (days)")) %>% 
  kable_styling() %>% scroll_box(height="400px")
```
## **Question #2**
### Do categories of service requests seem to be related to time of year?
```{r q2, echo=FALSE, results="hide", cache=TRUE}
ty <- mutate(sub, month_created=lubridate::month(sub$created_date,label=TRUE)) %>% 
      filter((month(created_date)>=month(Sys.Date()) & 
                day(created_date)>day(Sys.Date()) & 
                lubridate::year(created_date)==lubridate::year(Sys.Date())-1
              )|
               lubridate::year(created_date)==lubridate::year(Sys.Date())
             ) %>% 
      group_by(sr_type, month_created) %>% summarize(total_req=n()) %>% 
      spread(month_created, total_req)
ty[is.na(ty)] <- 0
ty_sum <- mutate(ungroup(ty), 
                  max = do.call(pmax, c(ty[,-1], na.rm=TRUE)),
                  min = do.call(pmin, c(ty[,-1], na.rm=TRUE))) %>%
                  mutate(.,cv = apply(ty[,c(2:13)], 1,function(x){
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100}))
#high variance codes with a maximum request count of at least 10
ty_hvc <- filter(ty_sum, cv > 100 & max > 10)

to_plot <- select(ty_hvc, sr_type,Jan:Dec) %>% 
           gather(key="month", value="count", -sr_type)
to_plot$month <- factor(to_plot$month, month.abb)

ty_ggplot <- ggplot(to_plot, aes(x=month, y=count, group=1)) +
        geom_line() +
        facet_wrap(~str_wrap(sr_type,width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(angle = 270, hjust = 1))
today_day <- day(Sys.Date())
today_month <- as.character(lubridate::month(Sys.Date(), label=TRUE,abbr=FALSE))
today_year <- lubridate::year(Sys.Date())
```

In order to relate the service requests counts to time of year I decided to figure out how many of each service request was created per month. To do this I first added a column to the sub table which labels the month that each request was created. Based on this column I was then able to create a smaller summary table that displayed the number of requests of each type per month. I encountered an issue here based on the fact that this data set was not limited to one contiguous year. That is to say, some months had data from both 2018 and 2019. I used a filter function to ensure that the data analyzed only included counts from days in 2018 after the current date (e.g. today is `r today_month` `r today_day`, `r today_year` so data should start from `r today_month` `r (today_day+1)`, `r (today_year-1)`).

```{r q2_table, echo=FALSE}
kable(select(ty_sum, -max,-min,-cv),align="lc", 
      col.names=c("Request Type", month.abb)) %>% 
  kable_styling() %>% scroll_box(height="400px")
```
<br>
From this table I was then able to calculate the coefficient of variation for each request type to find those with the *most* variance over a year. I took the most variant request types (coefficient of variation > 100) that had a high enough *maximum* number of requests in one month and plotted their *total* number of requests per month. 

```{r q2_plot, echo=FALSE}
print(ty_ggplot)
```

These graphs show a pretty clear pattern of certain service requests being much more common in different times of the year. Requests related to outdoor work or activities (bee/wasp removal, pushcart food vendor complaints, open fire hydrant complaints for example) are much more common in the warmer months. Conversely requests related to snow and ice are much more common in the colder months.
```{r q2_code, eval=FALSE}
ty <- mutate(sub, month_created=lubridate::month(sub$created_date,label=TRUE)) %>% 
      filter((month(created_date)>=month(Sys.Date()) & 
                day(created_date)>day(Sys.Date()) & 
                lubridate::year(created_date)==lubridate::year(Sys.Date())-1
              )|
               lubridate::year(created_date)==lubridate::year(Sys.Date())
             ) %>% 
      group_by(sr_type, month_created) %>% summarize(total_req=n()) %>% 
      spread(month_created, total_req)
ty[is.na(ty)] <- 0
ty_sum <- mutate(ungroup(ty), 
                  max = do.call(pmax, c(ty[,-1], na.rm=TRUE)),
                  min = do.call(pmin, c(ty[,-1], na.rm=TRUE))) %>%
                  mutate(.,cv = apply(ty[,c(2:13)], 1,function(x){
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100}))
#high variance codes with a maximum request count of at least 10
ty_hvc <- filter(ty_sum, cv > 100 & max > 10)

to_plot <- select(ty_hvc, sr_type,Jan:Dec) %>% 
           gather(key="month", value="count", -sr_type)
to_plot$month <- factor(to_plot$month, month.abb)

ty_ggplot <- ggplot(to_plot, aes(x=month, y=count, group=1)) +
        geom_line() +
        facet_wrap(~str_wrap(sr_type,width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(angle = 270, hjust = 1))
today_day <- day(Sys.Date())
today_month <- as.character(lubridate::month(Sys.Date(), label=TRUE,abbr=FALSE))
today_year <- lubridate::year(Sys.Date())

#generate output table
kable(select(ty_sum, -max,-min,-cv),align="lc", 
      col.names=c("Request Type", month.abb)) %>% 
  kable_styling() %>% scroll_box(height="400px")

#generate output plot
print(ty_ggplot)
```
## **Question #3**
### Do categories of service requests seem to be related to time of day?
```{r q3, echo=FALSE, results="hide"}
td <- mutate(sub, time_exact=make_datetime(hour=hour(sub$created_date),
                                               min=minute(sub$created_date),
                                               sec=second(sub$created_date)) %>% 
                             format(format="%H:%M:%S"),
                  time_hour=hour(sub$created_date)) %>% 
      group_by(sr_type, time_hour) %>% summarize(total_req=n()) %>% 
      spread(time_hour, total_req)
td[is.na(td)] <- 0
td_sum <- mutate(ungroup(td), 
                 max = do.call(pmax, c(td[,-1], na.rm=TRUE))) %>% 
                 mutate(., cv = apply(td[,c(2:25)], 1,function(x){ 
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100} ))
td_hvc <- filter(td_sum, cv > 100 & max > 20)

to_plot <- select(td_hvc, sr_type, `0`:`23`) %>% 
           gather(key="hour", value="count", -sr_type)
to_plot$hour <- as.numeric(to_plot$hour)

td_ggplot <- ggplot(to_plot, aes(x=hour, y=count, group=1)) +
        geom_line() +
        scale_x_continuous(breaks=unique(to_plot$hour)[unique(to_plot$hour)%%2==0], 
               labels=c("12am", paste0(c(2,4,6,8,10),"am"), "12pm", paste0(c(2,4,6,8,10),"pm"))) +
        facet_wrap(~str_wrap(sr_type, width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(size=7, angle = 270, hjust=-0.25, vjust = 0.5))
```

To look at the same requests counts over time of day was a similar process as time of year. I broke the sub table down by approximate hour of creation this time and created a summary of requests per hour for each type of request. The rest of the process was basically the same. I used this summary of requests per hour to create a coefficient of variation for each request type and used only the most variant request types (coefficient of variation > 100) that had at least a maximum of 20 requests in one hour.

```{r q3_plot, echo=FALSE}
print(td_ggplot)
```

The general pattern shown by most of the above graphs is that most requests are made before midday, by people in the morning or perhaps on their lunch breaks. The only request that differs is the "Vehicle Parked in Bike Lane Complaint" which seems to have two peaks that correspond roughly with peak rush hour times in the city. This makes sense because if there are significantly more people on the road, including bikers, there are more opportunities for that type of complaint to be made.
```{r q3_code, eval=FALSE}
td <- mutate(sub, time_exact=make_datetime(hour=hour(sub$created_date),
                                               min=minute(sub$created_date),
                                               sec=second(sub$created_date)) %>% 
                             format(format="%H:%M:%S"),
                  time_hour=hour(sub$created_date)) %>% 
      group_by(sr_type, time_hour) %>% summarize(total_req=n()) %>% 
      spread(time_hour, total_req)
td[is.na(td)] <- 0
td_sum <- mutate(ungroup(td), 
                 max = do.call(pmax, c(td[,-1], na.rm=TRUE))) %>% 
                 mutate(., cv = apply(td[,c(2:25)], 1,function(x){ 
                                  (sd(x, na.rm=TRUE)/mean(x, na.rm=TRUE))*100} ))
td_hvc <- filter(td_sum, cv > 100 & max > 20)

to_plot <- select(td_hvc, sr_type, `0`:`23`) %>% 
           gather(key="hour", value="count", -sr_type)
to_plot$hour <- as.numeric(to_plot$hour)

td_ggplot <- ggplot(to_plot, aes(x=hour, y=count, group=1)) +
        geom_line() +
        scale_x_continuous(breaks=unique(to_plot$hour)[unique(to_plot$hour)%%2==0], 
               labels=c("12am", paste0(c(2,4,6,8,10),"am"), "12pm", paste0(c(2,4,6,8,10),"pm"))) +
        facet_wrap(~str_wrap(sr_type, width=19), scales="free_y") +
        theme_classic() +
        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),
              axis.text.x = element_text(size=7, angle = 270, hjust=-0.25, vjust = 0.5))
#generate output plot
print(td_ggplot)
```
## **Question #4**
### Which departments are best/worst at closing requests quickly?
```{r q4, echo=FALSE}
dep_sp <- select(sr, owner_department, sr_type, 
                 status, created_date, closed_date) %>% 
          filter(status=="Completed") %>% select(-status)
dep_sp[,3:4] <- lapply(dep_sp[,3:4], mdy_hms)
dep_sp <- mutate(dep_sp, dur_sec = as.numeric(difftime(dep_sp$closed_date,
                                                dep_sp$created_date))
                ) %>% group_by(owner_department, sr_type) %>% 
       summarise(day_diff = difftime(closed_date,created_date, units="days") %>% 
              mean() %>% round(digits=8), count=n()) %>% filter(day_diff>0.5)
avg_speed <- summarize(dep_sp, avg_req_n_days=mean(day_diff) %>% round (2))
avg_speed$owner_department <- gsub(".*?- ","", avg_speed$owner_department)
avg_speed$owner_department <- ifelse(grepl("^Department of ",avg_speed$owner_department),
                                     avg_speed$owner_department,
                                     gsub("^","Department of ",avg_speed$owner_department))
min_dep <- avg_speed$owner_department[which(avg_speed$avg_req_n_days==
                                              min(avg_speed$avg_req_n_days))]
min_dep_time <- as.numeric(avg_speed$avg_req_n_days[which(
                      avg_speed$avg_req_n_days==min(avg_speed$avg_req_n_days))])
max_dep <-  avg_speed$owner_department[which(avg_speed$avg_req_n_days==
                                               max(avg_speed$avg_req_n_days))]
max_dep_time <- as.numeric(avg_speed$avg_req_n_days[which(
                      avg_speed$avg_req_n_days==max(avg_speed$avg_req_n_days))])
```

This question required a slightly different subset of the original data set. In this case I selected columns related to service request type and date, but also selected the `owner_department` column. To figure out which departments were the fastest and which were the slowest I used the "created" and "closed" dates for each request type. I used this column to create a summary of average time differential (in days) of the "created" and "closed" dates to get an average lifespan for each request type per department. Averaging these numbers together gives an average lifespan for a request for each department. From there it's as simple as sorting by lifespan.  

***
```{r q4_table, echo=FALSE, results = 'asis'}
kable(avg_speed,align="lr",col.names=c("", "Average Life of Request (days)"))
```
***
The results of the analysis found that the fastest department was the **`r min_dep`**, with an average completion time of **`r min_dep_time` days**. The slowest request type fulfilled was the **`r max_dep`**, with an average completion time of **`r max_dep_time` days**.
```{r q4_code, eval=FALSE}
dep_sp <- select(sr, owner_department, sr_type, 
                 status, created_date, closed_date) %>% 
          filter(status=="Completed") %>% select(-status)
dep_sp[,3:4] <- lapply(dep_sp[,3:4], mdy_hms)
dep_sp <- mutate(dep_sp, dur_sec = as.numeric(difftime(dep_sp$closed_date,
                                                dep_sp$created_date))
                ) %>% group_by(owner_department, sr_type) %>% 
       summarise(day_diff = difftime(closed_date,created_date, units="days") %>% 
              mean() %>% round(digits=8), count=n()) %>% filter(day_diff>0.5)
avg_speed <- summarize(dep_sp, avg_req_n_days=mean(day_diff) %>% round (2))
avg_speed$owner_department <- gsub(".*?- ","", avg_speed$owner_department)
avg_speed$owner_department <- ifelse(grepl("^Department of ",avg_speed$owner_department),
                                     avg_speed$owner_department,
                                     gsub("^","Department of ",avg_speed$owner_department))
min_dep <- avg_speed$owner_department[which(avg_speed$avg_req_n_days==
                                              min(avg_speed$avg_req_n_days))]
min_dep_time <- as.numeric(avg_speed$avg_req_n_days[which(
                      avg_speed$avg_req_n_days==min(avg_speed$avg_req_n_days))])
max_dep <-  avg_speed$owner_department[which(avg_speed$avg_req_n_days==
                                               max(avg_speed$avg_req_n_days))]
max_dep_time <- as.numeric(avg_speed$avg_req_n_days[which(
                      avg_speed$avg_req_n_days==max(avg_speed$avg_req_n_days))])

#generate output table
kable(avg_speed,align="lr",col.names=c("", "Average Life of Request (days)"))
```